\section{Compiler Structure}
The compiler structure for languages such as C and C++ are of the old design described in the dragon book \cite{Aho:1986:CPT:6448}, where the entire code base are compiled every time a change is made, and the resulting code needs to be verified, linked and so on.
This can be a speed bump for developers who rely on compilation to catch all sorts of problems or who need to change the code base multiple times to get a desired result. The compilation process are required to be close to instant for such instances, otherwise productivity will go down.

In a video interview \cite{youtubeAndersHejlsberg}, they explain how compilers of this structure have some problems with modern usage in an \ac{IDE} and other tools. The reason for this being that such usage requires the compiler to verify the code, and give semantically correct suggestions, after each keystroke from the user. Doing the interview they also argue that compilers need to be able to verify and compile only the part of the code base that has changed since last compilation, by keeping an read-only in-memory \ac{AST} for each file in a given project that can be reused in the next compilation, so only the changed file needs recompilation, which will make subsequent compilations faster. They also explain how modern compilers need to be able to work with incomplete or incorrect source code, since the user of an \ac{IDE} most of the time is writing and while the user is writing the source code will be incomplete and therefore invalid. So a modern compiler should be able to make guesses on how to complete the code, so it can compile it and give suggestions to the user.

\subsection{Tooling support}
In the interview they also describe how the design for the C\# Roslyn compiler \cite{github:roslyn} is more like an \ac{API} instead of a traditional compiler, which make tool integration with the compiler easier since the different tools can use different parts of the compiler API, depending on the needs of the tool.
Since tools for code completion, such as IntelliSense\cite{micro:intelliSense}, refactoring and linting is commonly used in software development in general, good support for such tools would be nice to have as it could improve the development speed.

\subsection{Multithreading}
The compiler design explained by interviewee would also make it easier to multithread the compilation process, since each file in a project can be compiled separately, though dependencies between some of the files will be present.
Since game development projects often contain many files, often with many lines of code, being able to utilise more threads for the compilation process will speed it up, thereby increasing the productivity of the developers by giving them the information and suggestions in the \ac{IDE} quicker.
