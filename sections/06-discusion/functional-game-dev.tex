\section{Functional Programming Approaches}
During this report we have examined two approaches to functional programming in game development. The first (see \secref{functional-game-dev}), treating the functional paradigm as an approach in imperative languages and the second approach (see \secref{para-approach}), fully functional environments.

The first approach is supported in languages such as C\# or Java. These languages have implemented many concepts from the functional paradigm and therefore referred to as multiparadigm languages \cite{albahari2017c, raffles2018history}. This eases the use of the functional paradigm in said languages and by extension the game engines using these languages. Mono C\# supports higher order functions, anonymous types and lambda expressions, and thus so does Unity, CryEngine and Godot. The first approach, proposed by John Carmack \cite{gamasutra:c++functional}, has become supported at the language level for higher abstraction languages in game development.

The second approach, proposed by Tim Sweeney \cite{theNextMainstreanProgrammingLanguage}, differs from the first somewhat. Where the first approach begins in an imperative mindset and moves towards the functional paradigm, the second approach argues that the functional paradigm should be the first priority and move towards the imperative paradigm when necessary. This approach is not as supported in current game development languages, however, it may be possible. C\# supports a number of functional concepts that may be employed to construct a \ac{DSL} over C\# which supports the second approach.

Such a \ac{DSL} would be executable in current game engines, but might incur an additional performance overhead (see \secref{functional-overhead}). Furthermore, the \ac{DSL} may be specific for the game under development, instead of game development in general.
